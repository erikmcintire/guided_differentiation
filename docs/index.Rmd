---
title: "Guided_Differentiation_Code"
author: "Erik McIntire"
output: html_document
---
  
**LICENSE**  
Guided_Differentiation_Code Non-commercial License  
© 2023 The University of Chicago.  
  
Redistribution and use for noncommercial purposes in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   
  
1. The software is used solely for noncommercial purposes. It may not be used indirectly for commercial use, such as on a website that accepts advertising money for content. Noncommercial use does include use by a for-profit company in its research. For commercial use rights, contact The University of Chicago, Polsky Center for Entrepreneurship, and Innovation, at polskylicensing@uchicago.edu or call 773-702-1692 and inquire about Tech ID 22-T-080 project.   
  
2. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.   
  
3. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.   
  
4. Neither the name of The University of Chicago nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.   
  
THIS SOFTWARE IS PROVIDED  BY  THE  UNIVERSITY  OF CHICAGO  AND CONTRIBUTORS “AS IS” AND  ANY  EXPRESS  OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT LIMITED  TO,   THE  IMPLIED WARRANTIES  OF MERCHANTABILITY  AND  FITNESS FOR  A PARTICULAR  PURPOSE ARE DISCLAIMED. IN NO  EVENT  SHALL THE  UNIVERSITY OF  CHICAGO OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  OR  BUSINESS  INTERRUPTION) HOWEVER CAUSED  AND ON  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  THIS  SOFTWARE, EVEN  IF  ADVISED OF  THE POSSIBILITY OF SUCH DAMAGE.  
  
    
```{r setup, include=FALSE}
# Clear all objects
rm(list = ls())

# Enable code echo
knitr::opts_chunk$set(echo = TRUE)

# Set working directory
knitr::opts_knit$set(root.dir = "/project2/gilad/emcintire")

# Set deconvolution directory
dir <- "guided_differentiation_2021/220510_A00639_1151_BH3YKKDRX2-YG-EM-17S-lns12/YG-EM-ln1-EM314_human/"
```


```{r, eval=TRUE, echo=FALSE}
# Load packages
suppressPackageStartupMessages({
  library(Matrix, lib.loc = "/software/R-4.2.0-el7-x86_64/lib64/R/library")
  library(SeuratObject, lib.loc = "/software/R-4.2.0-el7-x86_64/lib64/R/library")
  library(data.table)
  library(cowplot)
  library(ggrepel)
  library(tidyverse)
  library(elementalist)
  library(ggrepel)
  library(patchwork)
  library(RColorBrewer)
  library(ggalluvial)
  library(Seurat, lib.loc = "/software/R-4.2.0-el7-x86_64/lib64/R/library")
  library(scPred)
  library(caret)
  library(lattice)
})

# Set global size limit for SCTransform
options(future.globals.maxSize = 1024 * 1024^3)

# Set working directory
setwd("/project2/gilad/emcintire")
```


**FIGURE 1 CELL CLUSTERING, ANALYSIS, AND ANNOTATION**
```{r, eval=TRUE, echo=TRUE}
# Read 10x data
guided_raw_data <- Read10X("guided_differentiation_2021/220510_A00639_1151_BH3YKKDRX2-YG-EM-17S-lns12/YG-EM-ln1-EM314_human/outs/filtered_feature_bc_matrix/")

# Create Seurat object from raw data
guided_obj <- CreateSeuratObject(guided_raw_data, min.cells = 1)

# Add Vireo information (demultiplex to identify individuals)
add_vireo <- function(guided_obj, dir) {
  donor_ids <- read.table(paste0(dir, 'vireo/donor_ids.tsv'), 
                          header = TRUE, stringsAsFactors = FALSE)
  
  guided_obj <- AddMetaData(guided_obj, donor_ids$donor_id,   
                            col.name ='vireo.individual')
  guided_obj <- AddMetaData(guided_obj, donor_ids$prob_max,   
                            col.name ='vireo.prob.singlet')
  
  ambient.file <- paste0(dir, 'vireo/prop_ambient.tsv')
  if (file.exists(ambient.file)) {
    prop <- read.table(paste0(dir, 'vireo/prop_ambient.tsv'), 
                       header = TRUE, stringsAsFactors = FALSE)
    
    inds <- unique(donor_ids$best_singlet)
    donor_ids$prop_donor <- 0
    for (i in 1:length(inds)) {
      w <- which(donor_ids$best_singlet==inds[i])
      donor_ids$prop_donor[w] <- prop[w,inds[i]]
    }
    guided_obj <- AddMetaData(guided_obj, donor_ids$prop_donor, 
                              col.name ='vireo.prop.donor')
  }
  guided_obj
}

guided_obj <- add_vireo(guided_obj, dir)

individual.colname <- ('vireo.individual')
individual.colname <- individual.colname[which(individual.colname %in% 
                                                 colnames(guided_obj@meta.data))][1]
```



```{r, eval=TRUE, echo=TRUE}
# Subset cells for each category
NA19114_obj <- subset(guided_obj, subset = vireo.individual == "NA19114")
NA19130_obj <- subset(guided_obj, subset = vireo.individual == "NA19130")
NA19152_obj <- subset(guided_obj, subset = vireo.individual == "NA19152")
doublet_obj <- subset(guided_obj, subset = vireo.individual == "doublet")
unassigned_obj <- subset(guided_obj, subset = vireo.individual == "unassigned")

# Function to print object information
print_info <- function(obj, name) {
  cat("\n", name, ":\n")
  print(obj)
}

# Print information for each object
print_info(NA19114_obj, "NA19114")
print_info(NA19130_obj, "NA19130")
print_info(NA19152_obj, "NA19152")
print_info(doublet_obj, "doublet")
print_info(unassigned_obj, "unassigned")
print_info(guided_obj, "total")
```


```{r, eval=TRUE, echo=TRUE}
# Filter out doublets, unassigned cells, and cells with fewer than 1500 features
guided_obj <- subset(guided_obj, subset = vireo.individual != "doublet")
guided_obj <- subset(guided_obj, subset = vireo.individual != "unassigned")
guided_obj <- subset(guided_obj, subset = nFeature_RNA >= 1500)

# Print total cells and features after filtering
print(guided_obj)
```


```{r, eval=TRUE, echo=TRUE}
# Apply SCTransform, PCA, UMAP, and FindNeighbors
guided_obj_sct <- SCTransform(guided_obj, 
                              variable.features.n = 5000, 
                              verbose = FALSE)
guided_obj_sct <- RunPCA(guided_obj_sct, npcs = 50, verbose = FALSE)
guided_obj_sct <- RunUMAP(guided_obj_sct, dims = 1:50, verbose = FALSE)
# Break
guided_obj_sct <- FindNeighbors(guided_obj_sct, dims = 1:50, verbose = FALSE)
```


```{r, eval=TRUE, echo=TRUE}
# UMAP color palette
umap_colors <- c("#117733", # green 
                 "#AA4499", # purple
                 "#CC6677", # rose
                 "#999933", # olive
                 "#4477AA", # blue
                 "#332288", # indigo
                 "#C45F00", # orange
                 "#882255", # wine
                 "#44AA99", # teal
                 "#DDCC77") # sand

# Bar plot color palette
bar_colors <- c("#C45F00", # orange
                "#882255", # wine
                "#DDCC77", # sand
                "#44AA99", # teal 
                "#332288", # indigo
                "#AA4499", # purple
                "#117733", # green
                "#4477AA", # blue
                "#999933", # olive                   
                "#CC6677") # rose
```


```{r, eval=TRUE, echo=TRUE}
# Set cluster resolution and reorder clusters
guided_obj_sct <- FindClusters(guided_obj_sct, resolution = 0.3, verbose = FALSE)
my_levels <- c('0', '3', '2', '1', '6', '7', '8', '4', '5', '9')
guided_obj_sct@active.ident <- factor(guided_obj_sct@active.ident, 
                                      levels = my_levels)

# Name clusters by cell types
new_cluster_ids <- c("Cardiomyocytes", 
                     "Second heart field", 
                     "Fibroblasts", 
                     "Epicardial cells", 
                     "First heart field", 
                     "Endocardial cells", 
                     "Hepatic endoderm", 
                     "Foregut endoderm", 
                     "Neuroectoderm", 
                     "Pluripotent stem cells")
names(new_cluster_ids) <- levels(guided_obj_sct)
guided_obj_sct <- RenameIdents(guided_obj_sct, new_cluster_ids)
guided_obj_sct$cell_type <- Idents(guided_obj_sct)

# UMAP plot
guided_obj_sct_umap <- DimPlot(guided_obj_sct, reduction = "umap", 
                               cols = umap_colors) + NoLegend() +
  theme(axis.title = element_text(size = 8), axis.ticks = element_blank(), 
        axis.text = element_blank(), panel.background = element_blank()) +
  xlab("UMAP 1") + ylab("UMAP 2")

# Bar plot for cell type percentages
totals <- as.data.frame(table(guided_obj_sct@active.ident)) %>%
  mutate(Percent = scales::label_percent(accuracy = .1)(Freq / sum(Freq))) %>%
  rename(Type = Var1, Count = Freq) %>%
  mutate(Type = factor(Type, levels = c("Hepatic endoderm", 
                                        "Foregut endoderm", 
                                        "Pluripotent stem cells", 
                                        "Neuroectoderm", 
                                        "Endocardial cells", 
                                        "Second heart field", 
                                        "Cardiomyocytes", 
                                        "First heart field", 
                                        "Epicardial cells", 
                                        "Fibroblasts")))

bar <- ggplot(totals, aes(x = Type, y = Count, fill = Type)) +
  geom_bar(stat = "identity") +
  coord_flip(clip = "off") +
  geom_text(aes(label = Percent), size = 2, hjust = -0.01) +
  scale_fill_manual(values = bar_colors) +
  NoLegend() +
  theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), 
        axis.text.y = element_text(size = 9), 
        axis.text.x = element_text(size = 8), 
        panel.background = element_blank())

# Plot layout
umap_layout <- c(area(1, 1), area(1, 2))
p <- guided_obj_sct_umap + bar + plot_layout(design = umap_layout)

# Print plot
print(p)
```


```{r, eval=TRUE, echo=FALSE}
# Function to calculate aspect ratio of ggplot
calculateAspectRatio <- function(plot, defaultAspectRatio = -1) {
  plotBuild <- ggplot_build(plot)
  aspectRatio <- plotBuild$plot$coordinates$ratio
  plotTable <- ggplot_gtable(plotBuild)
  widthsNull <- sapply(plotTable$widths, attr, "unit")
  heightsNull <- sapply(plotTable$heights, attr, "unit")
  if (any(widthsNull == "null"))
    aspectRatio <- unlist(plotTable$widths[widthsNull == "null"]) / unlist(plotTable$heights[heightsNull == "null"])
  if (is.null(aspectRatio)) aspectRatio <- defaultAspectRatio
  aspectRatio[1]
}

# Uncomment to save the last plot with specified settings
# ggsave(filename = "fig1B_13Nov23.tiff", height = 3, dpi = 600, plot = last_plot(), device = tiff, scale = 1, limitsize = TRUE, bg = NULL)
```


```{r, eval=TRUE, echo=TRUE, warning=FALSE, fig.width=5}
# Marker gene expression plot by cluster
features <- c("POU5F1", 
              "L1TD1", 
              "SOX2", 
              "CRABP1", 
              "HHEX", 
              "FOXA2", 
              "AFP", 
              "KDR", 
              "CDH5", 
              "PECAM1", 
              "NFATC1", 
              "TBX5", 
              "TBX20", 
              "WT1", 
              "TBX18", 
              "BMP4", 
              "COL3A1", 
              "LUM", 
              "POSTN", 
              "EYA1", 
              "ISL1", 
              "FGF10",
              "TNNT2", 
              "ACTN2", 
              "RYR2", 
              "CACNA1C", 
              "TNNI3")

p <- DotPlot(guided_obj_sct, features = features, col.min = 0, 
             cols = c("light gray", "dark red")) + 
  theme_linedraw() + 
  theme(
    legend.direction = "horizontal",
    legend.position = "bottom",
    legend.title = element_text(size = 9),
    legend.text = element_text(size = 9),
    axis.title.y = element_blank(), 
    axis.title.x = element_blank(), 
    axis.text.x = element_text(angle = 60, vjust = 0, hjust = 0),
    axis.text.y = element_text(colour = umap_colors, face = "bold")
  ) +
  scale_x_discrete(position = "top")

print(p)
```


```{r, eval=TRUE, echo=FALSE}
# Function to calculate aspect ratio of ggplot
calculateAspectRatio <- function(plot, defaultAspectRatio = -1) {
  plotBuild <- ggplot_build(plot)
  aspectRatio <- plotBuild$plot$coordinates$ratio
  plotTable <- ggplot_gtable(plotBuild)
  widthsNull <- sapply(plotTable$widths, attr, "unit")
  heightsNull <- sapply(plotTable$heights, attr, "unit")
  if (any(widthsNull == "null"))
    aspectRatio <- unlist(plotTable$widths[widthsNull == "null"]) / unlist(plotTable$heights[heightsNull == "null"])
  if (is.null(aspectRatio)) aspectRatio <- defaultAspectRatio
  aspectRatio[1]
}

# Uncomment to save the last plot with specified settings
# ggsave(filename = "fig1B_13Nov23.tiff", height = 3, dpi = 600, plot = last_plot(), device = tiff, scale = 1, limitsize = TRUE, bg = NULL)
```


```{r, eval=TRUE, echo=TRUE}
# Subset guided_obj_sct for specific individuals
NA19114_obj_sct <- subset(guided_obj_sct, 
                          subset = vireo.individual == "NA19114")

NA19130_obj_sct <- subset(guided_obj_sct, 
                          subset = vireo.individual == "NA19130")

NA19152_obj_sct <- subset(guided_obj_sct, 
                          subset = vireo.individual == "NA19152")
```


```{r, eval=TRUE, echo=TRUE}
# UMAP plot for cell line NA19114
NA19114_umap <- DimPlot(NA19114_obj_sct, reduction = "umap", 
                        cols = umap_colors) + NoLegend() +
  theme(
    axis.title.y = element_text(size = 8),
    axis.ticks.y = element_blank(),
    axis.text.y = element_blank(),
    axis.title.x = element_text(size = 8),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    panel.background = element_blank()
  ) +
  xlab("UMAP 1") + ylab("UMAP 2")

# Bar plot for cell type percentages in NA19114
NA19114_totals <- as.data.frame(table(NA19114_obj_sct@active.ident)) %>%
  mutate(Percent = scales::label_percent(accuracy = .1)(Freq / sum(Freq))) %>%
  rename(Type = Var1, Count = Freq) %>%
  mutate(Type = factor(Type, levels = c(
    "Hepatic endoderm",
    "Foregut endoderm",
    "Pluripotent stem cells",
    "Neuroectoderm",
    "Endocardial cells",
    "Second heart field",
    "Cardiomyocytes",
    "First heart field",
    "Epicardial cells",
    "Fibroblasts"
  )))

NA19114_bar <- ggplot(NA19114_totals, aes(x = Type, y = Count, fill = Type)) +
  geom_bar(stat = "identity") +
  coord_flip(clip = "off") +
  geom_text(aes(label = Percent), size = 2, hjust = -0.01) +
  scale_fill_manual(values = bar_colors) +
  NoLegend() +
  theme(
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.y = element_text(size = 9),
    axis.text.x = element_text(size = 8),
    panel.background = element_blank()
  )

# Combine UMAP and bar plot
p <- NA19114_umap + NA19114_bar + plot_layout(design = umap_layout)

print(p)
```


```{r, eval=TRUE, echo=FALSE}
# Function to calculate aspect ratio of ggplot
calculateAspectRatio <- function(plot, defaultAspectRatio = -1) {
  plotBuild <- ggplot_build(plot)
  aspectRatio <- plotBuild$plot$coordinates$ratio
  plotTable <- ggplot_gtable(plotBuild)
  widthsNull <- sapply(plotTable$widths, attr, "unit")
  heightsNull <- sapply(plotTable$heights, attr, "unit")
  if (any(widthsNull == "null"))
    aspectRatio <- unlist(plotTable$widths[widthsNull == "null"]) / unlist(plotTable$heights[heightsNull == "null"])
  if (is.null(aspectRatio)) aspectRatio <- defaultAspectRatio
  aspectRatio[1]
}

# Uncomment to save the last plot with specified settings
#ggsave(filename = "figS1A_13Nov23.tiff", height = 3,  dpi = 600, plot = last_plot(), device = tiff, scale = 1, limitsize = TRUE, bg = NULL)
```


```{r, eval=TRUE, echo=TRUE}
# UMAP plot for cell line NA19130
NA19130_umap <- DimPlot(NA19130_obj_sct, reduction = "umap", 
                        cols = umap_colors) + NoLegend() +
  theme(
    axis.title.y = element_text(size = 8),
    axis.ticks.y = element_blank(),
    axis.text.y = element_blank(),
    axis.title.x = element_text(size = 8),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    panel.background = element_blank()
  ) +
  xlab("UMAP 1") + ylab("UMAP 2")

# Bar plot for cell type percentages in NA19130
NA19130_totals <- as.data.frame(table(NA19130_obj_sct@active.ident)) %>%
  mutate(Percent = scales::label_percent(accuracy = .1)(Freq / sum(Freq))) %>%
  rename(Type = Var1, Count = Freq) %>%
  mutate(Type = factor(Type, levels = c(
    "Hepatic endoderm",
    "Foregut endoderm",
    "Pluripotent stem cells",
    "Neuroectoderm",
    "Endocardial cells",
    "Second heart field",
    "Cardiomyocytes",
    "First heart field",
    "Epicardial cells",
    "Fibroblasts"
  )))

NA19130_bar <- ggplot(NA19130_totals, aes(x = Type, y = Count, fill = Type)) +
  geom_bar(stat = "identity") +
  coord_flip(clip = "off") +
  geom_text(aes(label = Percent), size = 2, hjust = -0.01) +
  scale_fill_manual(values = bar_colors) +
  NoLegend() +
  theme(
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.y = element_text(size = 9),
    axis.text.x = element_text(size = 8),
    panel.background = element_blank()
  )

# Combine UMAP and bar plot
p <- NA19130_umap + NA19130_bar + plot_layout(design = umap_layout)

print(p)
```


```{r, eval=TRUE, echo=FALSE}
# Function to calculate aspect ratio of ggplot
calculateAspectRatio <- function(plot, defaultAspectRatio = -1) {
  plotBuild <- ggplot_build(plot)
  aspectRatio <- plotBuild$plot$coordinates$ratio
  plotTable <- ggplot_gtable(plotBuild)
  widthsNull <- sapply(plotTable$widths, attr, "unit")
  heightsNull <- sapply(plotTable$heights, attr, "unit")
  if (any(widthsNull == "null"))
    aspectRatio <- unlist(plotTable$widths[widthsNull == "null"]) / unlist(plotTable$heights[heightsNull == "null"])
  if (is.null(aspectRatio)) aspectRatio <- defaultAspectRatio
  aspectRatio[1]
}

# Uncomment to save the last plot with specified settings
#ggsave(filename = "figS1B_13Nov23.tiff", height = 3,  dpi = 600, plot = last_plot(), device = tiff, scale = 1, limitsize = TRUE, bg = NULL)
```


```{r, eval=TRUE, echo=TRUE}
# UMAP plot for cell line NA19152
NA19152_umap <- DimPlot(NA19152_obj_sct, reduction = "umap", 
                        cols = umap_colors) + NoLegend() +
  theme(
    axis.title.y = element_text(size = 8, color = "black"),
    axis.ticks.y = element_blank(),
    axis.text.y = element_blank(),
    axis.title.x = element_text(size = 8, colour = "black"),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    panel.background = element_blank()
  ) +
  xlab("UMAP 1") + ylab("UMAP 2")

# Bar plot for cell type percentages in NA19152
NA19152_totals <- as.data.frame(table(NA19152_obj_sct@active.ident)) %>%
  mutate(Percent = scales::label_percent(accuracy = .1)(Freq / sum(Freq))) %>%
  rename(Type = Var1, Count = Freq) %>%
  mutate(Type = factor(Type, levels = c(
    "Hepatic endoderm",
    "Foregut endoderm",
    "Pluripotent stem cells",
    "Neuroectoderm",
    "Endocardial cells",
    "Second heart field",
    "Cardiomyocytes",
    "First heart field",
    "Epicardial cells",
    "Fibroblasts"
  )))

NA19152_bar <- ggplot(NA19152_totals, aes(x = Type, y = Count, fill = Type)) +
  geom_bar(stat = "identity") +
  coord_flip(clip = "off") +
  geom_text(aes(label = Percent), size = 2, hjust = -0.01) +
  scale_fill_manual(values = bar_colors) +
  NoLegend() +
  theme(
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.y = element_text(size = 9, color = "black"),
    axis.text.x = element_text(size = 8, colour = "black"),
    panel.background = element_blank()
  )

# Combine UMAP and bar plot
p <- NA19152_umap + NA19152_bar + plot_layout(design = umap_layout) 
print(p)
```


```{r, eval=TRUE, echo=FALSE}
# Function to calculate aspect ratio of ggplot
calculateAspectRatio <- function(plot, defaultAspectRatio = -1) {
  plotBuild <- ggplot_build(plot)
  aspectRatio <- plotBuild$plot$coordinates$ratio
  plotTable <- ggplot_gtable(plotBuild)
  widthsNull <- sapply(plotTable$widths, attr, "unit")
  heightsNull <- sapply(plotTable$heights, attr, "unit")
  if (any(widthsNull == "null"))
    aspectRatio <- unlist(plotTable$widths[widthsNull == "null"]) / unlist(plotTable$heights[heightsNull == "null"])
  if (is.null(aspectRatio)) aspectRatio <- defaultAspectRatio
  aspectRatio[1]
}

# Uncomment to save the last plot with specified settings
#ggsave(filename = "figS1C_13Nov23.tiff", height = 3,  dpi = 600, plot = last_plot(), device = tiff, scale = 1, limitsize = TRUE, bg = NULL)
```


```{r, eval=TRUE, echo=TRUE}
# Subset foregut populations for supplemental materials
gut <- subset(guided_obj_sct, subset = seurat_clusters == 4)

# Apply SCTransform, PCA, UMAP, FindNeighbors, and FindClusters
gut <- SCTransform(gut, variable.features.n = 5000, verbose = FALSE)
gut <- RunPCA(gut, npcs = 50, verbose = FALSE)
gut <- RunUMAP(gut, dims = 1:50, verbose = FALSE)
gut <- FindNeighbors(gut, dims = 1:50, verbose = FALSE)
gut <- FindClusters(gut, resolution = 0.1, verbose = FALSE)

# Assign cluster names
gut_cluster_ids <- c("Anterior foregut", "Posterior foregut")    
names(gut_cluster_ids) <- levels(gut)
gut <- RenameIdents(gut, gut_cluster_ids)

# UMAP plot for gut data
p <- DimPlot(gut, reduction = "umap", cols = c("#0077BB", "#EE7733")) +
  theme(
    axis.title.y = element_text(size = 8, color = "black"),
    axis.ticks.y = element_blank(),
    axis.text.y = element_blank(),
    axis.title.x = element_text(size = 8, colour = "black"),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    panel.background = element_blank()
  ) +
  xlab("UMAP 1") + ylab("UMAP 2")  + coord_fixed(ratio = 1)

print(p)
```


```{r, eval=TRUE, echo=FALSE}
# Function to calculate aspect ratio of ggplot
calculateAspectRatio <- function(plot, defaultAspectRatio = -1) {
  plotBuild <- ggplot_build(plot)
  aspectRatio <- plotBuild$plot$coordinates$ratio
  plotTable <- ggplot_gtable(plotBuild)
  widthsNull <- sapply(plotTable$widths, attr, "unit")
  heightsNull <- sapply(plotTable$heights, attr, "unit")
  if (any(widthsNull == "null"))
    aspectRatio <- unlist(plotTable$widths[widthsNull == "null"]) / unlist(plotTable$heights[heightsNull == "null"])
  if (is.null(aspectRatio)) aspectRatio <- defaultAspectRatio
  aspectRatio[1]
}

# Uncomment to save the last plot with specified settings
#ggsave(filename = "figS3A_13Nov23.tiff", height = 3,  dpi = 600, plot = last_plot(), device = tiff, scale = 1, limitsize = TRUE, bg = NULL)
```


```{r, eval=TRUE, echo=TRUE}
# Violin plots for marker genes for anterior and posterior foregut
SOX2 <- VlnPlot(gut, "SOX2", cols = c("#0077BB", "#EE7733")) + NoLegend() +
  theme(axis.title.x = element_blank(), axis.text.x = element_text(size = 10), 
        axis.title.y = element_text(size = 12))

ISL1 <- VlnPlot(gut, "ISL1", cols = c("#0077BB", "#EE7733")) + NoLegend() +
  theme(axis.title.x = element_blank(), axis.text.x = element_text(size = 10), 
        axis.title.y = element_blank())

IRX3 <- VlnPlot(gut, "IRX3", cols = c("#0077BB", "#EE7733")) + NoLegend() +
  theme(axis.title.x = element_blank(), axis.text.x = element_text(size = 10), 
        axis.title.y = element_blank())

HNF4A <- VlnPlot(gut, "HNF4A", cols = c("#0077BB", "#EE7733")) + NoLegend() +
  theme(axis.title.x = element_blank(), axis.text.x = element_text(size = 10), 
        axis.title.y = element_text(size = 12))

PROX1 <- VlnPlot(gut, "PROX1", cols = c("#0077BB", "#EE7733")) + NoLegend() +
  theme(axis.title.x = element_blank(), axis.text.x = element_text(size = 10), 
        axis.title.y = element_blank())

FGB <- VlnPlot(gut, "FGB", cols = c("#0077BB", "#EE7733")) + NoLegend() +
  theme(axis.title.x = element_blank(), axis.text.x = element_text(size = 10), 
        axis.title.y = element_blank())

# Layout setup for multiple plots
gut_layout <- c(area(1, 1), area(1, 2), area(1, 3))
```


```{r, eval=TRUE, echo=TRUE}
# Combine violin plots of anterior foregut markers into one plot
p <- SOX2 + ISL1 + IRX3 + plot_layout(design = gut_layout)

print(p)
```


```{r, eval=TRUE, echo=FALSE}
# Function to calculate aspect ratio of ggplot
calculateAspectRatio <- function(plot, defaultAspectRatio = -1) {
  plotBuild <- ggplot_build(plot)
  aspectRatio <- plotBuild$plot$coordinates$ratio
  plotTable <- ggplot_gtable(plotBuild)
  widthsNull <- sapply(plotTable$widths, attr, "unit")
  heightsNull <- sapply(plotTable$heights, attr, "unit")
  if (any(widthsNull == "null"))
    aspectRatio <- unlist(plotTable$widths[widthsNull == "null"]) / unlist(plotTable$heights[heightsNull == "null"])
  if (is.null(aspectRatio)) aspectRatio <- defaultAspectRatio
  aspectRatio[1]
}

# Uncomment to save the last plot with specified settings
#ggsave(filename = "figS3B_13Nov23.tiff", height = 3,  dpi = 600, plot = last_plot(), device = tiff, scale = 1, limitsize = TRUE, bg = NULL)
```


```{r, eval=TRUE, echo=TRUE}
# Combine violin plots of posterior foregut markers into one plot
p <- HNF4A + PROX1 + FGB + plot_layout(design = gut_layout)

print(p)
```


```{r, eval=TRUE, echo=FALSE}
# Function to calculate aspect ratio of ggplot
calculateAspectRatio <- function(plot, defaultAspectRatio = -1) {
  plotBuild <- ggplot_build(plot)
  aspectRatio <- plotBuild$plot$coordinates$ratio
  plotTable <- ggplot_gtable(plotBuild)
  widthsNull <- sapply(plotTable$widths, attr, "unit")
  heightsNull <- sapply(plotTable$heights, attr, "unit")
  if (any(widthsNull == "null"))
    aspectRatio <- unlist(plotTable$widths[widthsNull == "null"]) / unlist(plotTable$heights[heightsNull == "null"])
  if (is.null(aspectRatio)) aspectRatio <- defaultAspectRatio
  aspectRatio[1]
}

# Uncomment to save the last plot with specified settings
#ggsave(filename = "figS3C_13Nov23.tiff", height = 3,  dpi = 600, plot = last_plot(), device = tiff, scale = 1, limitsize = TRUE, bg = NULL)
```


**FIGURE 2 PLOTTING OF GUIDED DIFFERENTIATION AND 16-DAY TIME-COURSE INTEGRATION**
```{r, eval=FALSE, echo=TRUE}
# Batch processing job due to high computational requirement
# Not run as part of this Rmarkdown

# Make the guided differentiation object
# Read in 10x data
guided_raw_data <- Read10X("guided_differentiation_2021/220510_A00639_1151_BH3YKKDRX2-YG-EM-17S-lns12/YG-EM-ln1-EM314_human/outs/filtered_feature_bc_matrix/")

# Create Seurat object
guided_obj <- CreateSeuratObject(counts = guided_raw_data, min.cells = 1)

# Add Vireo information (demultiplex to identify individuals)
add_vireo <- function(guided_obj, dir) {
  donor_ids <- read.table(paste0(dir, 'vireo/donor_ids.tsv'), 
                          header = TRUE, stringsAsFactors = FALSE)
  
  guided_obj <- AddMetaData(guided_obj, donor_ids$donor_id,   
                            col.name ='vireo.individual')
  guided_obj <- AddMetaData(guided_obj, donor_ids$prob_max,   
                            col.name ='vireo.prob.singlet')
  
  ambient.file <- paste0(dir, 'vireo/prop_ambient.tsv')
  if (file.exists(ambient.file)) {
    prop <- read.table(paste0(dir, 'vireo/prop_ambient.tsv'), 
                       header = TRUE, stringsAsFactors = FALSE)
    
    inds <- unique(donor_ids$best_singlet)
    donor_ids$prop_donor <- 0
    for (i in 1:length(inds)) {
      w <- which(donor_ids$best_singlet==inds[i])
      donor_ids$prop_donor[w] <- prop[w,inds[i]]
    }
    guided_obj <- AddMetaData(guided_obj, donor_ids$prop_donor, 
                              col.name ='vireo.prop.donor')
  }
  guided_obj
}

guided_obj <- add_vireo(guided_obj, dir)

individual.colname <- ('vireo.individual')
individual.colname <- individual.colname[which(individual.colname %in% 
                                                 colnames(guided_obj@meta.data))][1]

# Filter out doublets, unassigned cells, and cells with fewer than 1500 features
guided_obj <- subset(guided_obj, 
                     subset = vireo.individual != "doublet" & 
                       vireo.individual != "unassigned" & 
                       nFeature_RNA >= 1500)

# Make the time-course object
# Create list of directories containing DropSeq data
round1_dirs <- list.dirs(path = "dropseqRunner_round1/output", 
                         full.names = TRUE, 
                         recursive = TRUE)
round2_dirs <- list.dirs(path = "dropseqRunner_round2/output", 
                         full.names = TRUE, 
                         recursive = TRUE)
round3_dirs <- list.dirs(path = "dropseqRunner_round3/output", 
                         full.names = TRUE, 
                         recursive = TRUE)

# Combine directory lists
combined_dirs <- c(round1_dirs, round2_dirs, round3_dirs)
combined_dirs <- grep("*/Gene/raw", combined_dirs, value = TRUE)
combined_dirs <- as.data.frame(combined_dirs)

# Read in 10x data
rows <- nrow(combined_dirs)
mix_list <- list()
obj_list <- list()

for (i in 1:rows) {
  path <- as.character(combined_dirs[i, ])
  timecourse_raw_data <- Read10X(path)
  
  mixture <- str_match(path, "output/\\s*(.*?)\\s*_0_Solo")[, 2]
  mix_list[[i]] <- mixture
  
  timecourse_obj <- CreateSeuratObject(counts = timecourse_raw_data, 
                                       project = mixture, 
                                       assay = "RNA")
  obj_list[[i]] <- timecourse_obj
}

# Merge individual time-course objects
timecourse_obj <- merge(obj_list[[1]], 
                        y = obj_list[-1], 
                        add.cell.ids = mix_list)

# Only include genes expressed in ≥10 cells and cells expressing ≥300 genes
timecourse_obj <- CreateSeuratObject(counts = timecourse_obj@assays$RNA@counts, 
                                     min.cells = 10, 
                                     min.features = 300)

# Calculate the percentage of mitochondrial DNA and add as metadata
timecourse_obj[["percent.mt"]] <- PercentageFeatureSet(timecourse_obj, 
                                                       pattern = "^MT-")

#  Subset to exclude cells with more than 25% mitochondrial DNA content
timecourse_obj <- subset(timecourse_obj, subset = percent.mt <= 25)

# Prepare demuxlet files for integration
# List all demuxlet .best files
demux_files <- list.files(path="demux", 
                          pattern = "*_demux.best", 
                          full.names=TRUE)

# Initialize list for demuxlet dataframes
demux_list <- list()

# Loop to process each demuxlet file
for (i in 1:length(demux_files)) {
  # Read each demuxlet file
  demux_data <- fread(demux_files[[i]])

  # Extract mixture name from file path
  demux_name <- str_match(demux_files[[i]], "demux/\\s*(.*?)\\s*_demux")[,2]

  # Add mixture name as new column and prefix it to barcodes
  demux_data$orig.ident <- demux_name
  demux_data$BARCODE <- paste0(demux_name, "_", demux_data$BARCODE)

  # Add processed dataframe to the list
  demux_list[[i]] <- demux_data
}

# Merge all demuxlet dataframes into a single dataframe
demux_combined <- bind_rows(demux_list)

# Exclude cells with doublet probability greater than 0.3
demux_combined <- filter(demux_combined, PRB.DBL <= 0.3)
# Remove ambiguous cells
demux_combined <- filter(demux_combined, !grepl('AMB', BEST))

# Prepare collection data
# Read collection day dataframe
collect_data <- read.table(file = 'AllroundsCollectionInfo.tsv', 
                           sep = '\t', 
                           header = TRUE)

# Add a column for the full mixture ID name
collect_data <- mutate(collect_data, 
                       Mixture = paste0("E", collect_data$Exp, 
                                        "CD", collect_data$CD, 
                                        "col", collect_data$col))

# Subset to include relevant columns
collect_data <- subset(collect_data, select = c("Line", "Day", "Mixture"))

# Add collection day to demuxlet data
# Merge collection data with demuxlet data based on mixture and cell line
sample_info <- merge(demux_combined, collect_data, 
                     by.x=c('orig.ident', 'SNG.1ST'), 
                     by.y=c('Mixture', 'Line'), 
                     all = TRUE)

# Rename Demuxlet best singlet guess column to individual/cell line
sample_info <- sample_info %>% rename(Individual = SNG.1ST)

# Add sample information as metadata to object
# Set barcode column as row names for sample info
sample_coded <- column_to_rownames(sample_info, var = "BARCODE")

# Add sample metadata to time-course object
timecourse_obj <- AddMetaData(object = timecourse_obj, metadata = sample_coded)

# Remove cells not designated as singlets
timecourse_obj <- subset(timecourse_obj, subset = Individual != "NA")

# Filter cells based on feature and read counts
# Calculate upper and lower bounds for counts and features
count_max <- round(median(timecourse_obj$nCount_RNA) + 
                     4 * sd(timecourse_obj$nCount_RNA), digits = -2)

count_min <- max(0, round(median(timecourse_obj$nCount_RNA) - 
                            4 * sd(timecourse_obj$nCount_RNA), digits = -2))

feat_max <- round(median(timecourse_obj$nFeature_RNA) + 
                    4 * sd(timecourse_obj$nFeature_RNA), digits = -2)

feat_min <- max(0, round(median(timecourse_obj$nFeature_RNA) - 
                           4 * sd(timecourse_obj$nFeature_RNA), digits = -2))

# Filter cells that have features or reads above or below 4 s.d. from the median
timecourse_obj <- subset(timecourse_obj, 
                         subset = nFeature_RNA > feat_min & 
                           nFeature_RNA < feat_max & 
                           nCount_RNA < count_max & 
                           nCount_RNA > count_min)

# Combine and format objects
# Add origin metadata to each object
timecourse_obj <- AddMetaData(timecourse_obj, 
                              metadata="Time-course", 
                              col.name="Origin")

guided_obj <- AddMetaData(guided_obj, 
                          metadata="Guided differentiation", 
                          col.name="Origin")

# Merge objects and preface cell names with origin identifier
combined_obj <- merge(timecourse_obj, 
                      y = guided_obj, 
                      add.cell.ids = c("TC", "EB"), project = "compare")

# Replace missing 'Day' metadata in guided differentiation with 'EB'
combined_obj@meta.data$Day <- replace_na(combined_obj@meta.data$Day, 'EB')

# Process for SCTransform and integration
combined_obj <- SplitObject(combined_obj, split.by = "Origin")
combined_obj <- lapply(combined_obj, SCTransform, variable.features.n = 5000)
features <- SelectIntegrationFeatures(object.list = combined_obj, 
                                      nfeatures = 5000)
combined_obj <- PrepSCTIntegration(object.list = combined_obj, 
                                   anchor.features = features)
anchors <- FindIntegrationAnchors(object.list = combined_obj, 
                                  normalization.method = "SCT", 
                                  anchor.features = features)
combined_sct <- IntegrateData(anchorset = anchors, 
                              normalization.method = "SCT")
DefaultAssay(combined_sct) <- "integrated"
combined_sct <- RunPCA(combined_sct, npcs = 50)
combined_sct <- RunUMAP(combined_sct, dims = 1:50)
combined_sct <- FindNeighbors(combined_sct, dims = 1:50)

# Reorder day levels chronologically in combined_sct
combined_sct$Day <- factor(combined_sct$Day, 
                           levels = c('Day 0', 
                                      'Day 1', 
                                      'Day 3', 
                                      'Day 5', 
                                      'Day 7', 
                                      'Day 11', 
                                      'Day 15', 
                                      'EB'))

# Find clusters and prepare for differential expression analysis
int_obj <- FindClusters(combined_sct, resolution = 0.1)
int_obj <- PrepSCTFindMarkers(int_obj)
```


```{r, eval=TRUE, echo=FALSE}
# read in the integrated seurat object 
int_obj <- readRDS(file = "integration_analyses/Elorbany_2022/D7_combined_sct_CLUSTERED_12Nov23_forpub.rds")
```


```{r, eval=TRUE, echo=TRUE}
# Define a custom palette
my_seven_colors <- c("#117733",  # Green
                     "#882255",  # Wine
                     "#CC6677",  # Rose
                     "#999933",  # Olive
                     "#44AA99",  # Teal
                     "#332288",  # Indigo
                     "#AA4499")  # Purple

# Plot UMAP of the integrated object and split by origin
DimPlot(int_obj, group.by = 'Origin', cols = c("orange", "light blue"), 
        order = FALSE, raster = FALSE) + 
  theme(
    axis.title.y = element_text(size = 8, color = "black"),
    axis.ticks.y = element_blank(),
    axis.text.y = element_blank(),
    axis.title.x = element_text(size = 8, colour = "black"),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    panel.background = element_blank()
  ) +
  xlab("UMAP 1") + ylab("UMAP 2") + NoLegend()
```


```{r, eval=TRUE, echo=TRUE}
cells0_0 <- Cells(subset(x = int_obj, subset = Day == "Day 0" & seurat_clusters == 0))
cells0_1 <- Cells(subset(x = int_obj, subset = Day == "Day 0" & seurat_clusters == 1))
cells0_2 <- Cells(subset(x = int_obj, subset = Day == "Day 0" & seurat_clusters == 2))
cells0_3 <- Cells(subset(x = int_obj, subset = Day == "Day 0" & seurat_clusters == 3))
cells0_4 <- Cells(subset(x = int_obj, subset = Day == "Day 0" & seurat_clusters == 4))
cells0_5 <- Cells(subset(x = int_obj, subset = Day == "Day 0" & seurat_clusters == 5))
#cells0_6 <- Cells(subset(x = int_obj, subset = Day == "Day 0" & seurat_clusters == 6)) # no cells

day0 <- DimPlot(object = int_obj, cells.highlight = list(cells0_0, cells0_1, cells0_2, cells0_3, cells0_4, cells0_5), cols.highlight = c("#332288", "#44AA99", "#999933", "#CC6677", "#882255", "#117733"), cols = "#DDDDDD", order = TRUE, label = FALSE, raster = TRUE, raster.dpi = c(1024, 1024)) +
  ggtitle("Time-course (day 0)") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 11),
    panel.border = element_rect_round(radius = unit(0.1, "snpc"), color = "black", fill = NA)
  ) + NoLegend() + NoAxes()

print(day0)
```


```{r, eval=TRUE, echo=TRUE}
# Highlight time-course day 1 clusters
cells1_0 <- Cells(subset(x = int_obj, subset = Day == "Day 1" & seurat_clusters == 0))
cells1_1 <- Cells(subset(x = int_obj, subset = Day == "Day 1" & seurat_clusters == 1))
cells1_2 <- Cells(subset(x = int_obj, subset = Day == "Day 1" & seurat_clusters == 2))
cells1_3 <- Cells(subset(x = int_obj, subset = Day == "Day 1" & seurat_clusters == 3))
cells1_4 <- Cells(subset(x = int_obj, subset = Day == "Day 1" & seurat_clusters == 4))
cells1_5 <- Cells(subset(x = int_obj, subset = Day == "Day 1" & seurat_clusters == 5))
#cells1_6 <- Cells(subset(x = int_obj, subset = Day == "Day 1" & seurat_clusters == 6)) # no cells

day1 <- DimPlot(object = int_obj, cells.highlight = list(cells1_0, cells1_1, cells1_2, cells1_3, cells1_4, cells1_5), cols.highlight = c("#332288", "#44AA99", "#999933", "#CC6677", "#882255", "#117733"), cols = "#DDDDDD", order = TRUE, label = FALSE, raster = TRUE, raster.dpi = c(1024, 1024)) +
  ggtitle("Time-course (day 1)") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 11),
    panel.border = element_rect_round(radius = unit(0.1, "snpc"), color = "black", fill = NA)
  ) + NoLegend() + NoAxes()

print(day1)
```


```{r, eval=TRUE, echo=TRUE}
# Highlight time-course day 3 clusters
cells3_0 <- Cells(subset(x = int_obj, subset = Day == "Day 3" & seurat_clusters == 0))
cells3_1 <- Cells(subset(x = int_obj, subset = Day == "Day 3" & seurat_clusters == 1))
cells3_2 <- Cells(subset(x = int_obj, subset = Day == "Day 3" & seurat_clusters == 2))
cells3_3 <- Cells(subset(x = int_obj, subset = Day == "Day 3" & seurat_clusters == 3))
cells3_4 <- Cells(subset(x = int_obj, subset = Day == "Day 3" & seurat_clusters == 4))
cells3_5 <- Cells(subset(x = int_obj, subset = Day == "Day 3" & seurat_clusters == 5))
#cells3_6 <- Cells(subset(x = int_obj, subset = Day == "Day 3" & seurat_clusters == 6)) # no cells

day3 <- DimPlot(object = int_obj, cells.highlight = list(cells3_0, cells3_1, cells3_2, cells3_3, cells3_4, cells3_5), cols.highlight = c("#332288", "#44AA99", "#999933", "#CC6677", "#882255", "#117733"), cols = "#DDDDDD", order = TRUE, label = FALSE, raster = TRUE, raster.dpi = c(1024, 1024)) +
  ggtitle("Time-course (day 3)") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 11),
    panel.border = element_rect_round(radius = unit(0.1, "snpc"), color = "black", fill = NA)
  ) + NoLegend() + NoAxes()

print(day3)
```


```{r, eval=TRUE, echo=TRUE}
# Highlight time-course day 5 clusters
cells5_0 <- Cells(subset(x = int_obj, subset = Day == "Day 5" & seurat_clusters == 0))
cells5_1 <- Cells(subset(x = int_obj, subset = Day == "Day 5" & seurat_clusters == 1))
cells5_2 <- Cells(subset(x = int_obj, subset = Day == "Day 5" & seurat_clusters == 2))
cells5_3 <- Cells(subset(x = int_obj, subset = Day == "Day 5" & seurat_clusters == 3))
cells5_4 <- Cells(subset(x = int_obj, subset = Day == "Day 5" & seurat_clusters == 4))
cells5_5 <- Cells(subset(x = int_obj, subset = Day == "Day 5" & seurat_clusters == 5))
cells5_6 <- Cells(subset(x = int_obj, subset = Day == "Day 5" & seurat_clusters == 6))

day5 <- DimPlot(object = int_obj, cells.highlight = list(cells5_0, cells5_1, cells5_2, cells5_3, cells5_4, cells5_5, cells5_6), cols.highlight = c("#AA4499", "#332288", "#44AA99", "#999933", "#CC6677", "#882255", "#117733"), cols = "#DDDDDD", order = TRUE, label = FALSE, raster = TRUE, raster.dpi = c(1024, 1024)) +
  ggtitle("Time-course (day 5)") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 11),
    panel.border = element_rect_round(radius = unit(0.1, "snpc"), color = "black", fill = NA)
  ) + NoLegend() + NoAxes()

print(day5)
```


```{r, eval=TRUE, echo=TRUE}
# Highlight time-course day 7 clusters
cells7_0 <- Cells(subset(x = int_obj, subset = Day == "Day 7" & seurat_clusters == 0))
cells7_1 <- Cells(subset(x = int_obj, subset = Day == "Day 7" & seurat_clusters == 1))
cells7_2 <- Cells(subset(x = int_obj, subset = Day == "Day 7" & seurat_clusters == 2))
cells7_3 <- Cells(subset(x = int_obj, subset = Day == "Day 7" & seurat_clusters == 3))
cells7_4 <- Cells(subset(x = int_obj, subset = Day == "Day 7" & seurat_clusters == 4))
cells7_5 <- Cells(subset(x = int_obj, subset = Day == "Day 7" & seurat_clusters == 5))
cells7_6 <- Cells(subset(x = int_obj, subset = Day == "Day 7" & seurat_clusters == 6))

day7 <- DimPlot(object = int_obj, cells.highlight = list(cells7_0, cells7_1, cells7_2, cells7_3, cells7_4, cells7_5, cells7_6), cols.highlight = c("#AA4499", "#332288", "#44AA99", "#999933", "#CC6677", "#882255", "#117733"), cols = "#DDDDDD", order = TRUE, label = FALSE, raster = TRUE, raster.dpi = c(1024, 1024)) +
  ggtitle("Time-course (day 7)") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 11),
    panel.border = element_rect_round(radius = unit(0.1, "snpc"), color = "black", fill = NA)
  ) + NoLegend() + NoAxes()

print(day7)
```


```{r, eval=TRUE, echo=TRUE}
# Highlight time-course day 11 clusters
cells11_0 <- Cells(subset(x = int_obj, subset = Day == "Day 11" & seurat_clusters == 0))
cells11_1 <- Cells(subset(x = int_obj, subset = Day == "Day 11" & seurat_clusters == 1))
cells11_2 <- Cells(subset(x = int_obj, subset = Day == "Day 11" & seurat_clusters == 2))
cells11_3 <- Cells(subset(x = int_obj, subset = Day == "Day 11" & seurat_clusters == 3))
cells11_4 <- Cells(subset(x = int_obj, subset = Day == "Day 11" & seurat_clusters == 4))
cells11_5 <- Cells(subset(x = int_obj, subset = Day == "Day 11" & seurat_clusters == 5))
cells11_6 <- Cells(subset(x = int_obj, subset = Day == "Day 11" & seurat_clusters == 6))

day11 <- DimPlot(object = int_obj, cells.highlight = list(cells11_0, cells11_1, cells11_2, cells11_3, cells11_4, cells11_5, cells11_6), cols.highlight = c("#AA4499", "#332288", "#44AA99", "#999933", "#CC6677", "#882255", "#117733"), cols = "#DDDDDD", order = TRUE, label = FALSE, raster = TRUE, raster.dpi = c(1024, 1024)) +
  ggtitle("Time-course (day 11)") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 11),
    panel.border = element_rect_round(radius = unit(0.1, "snpc"), color = "black", fill = NA)
  ) + NoLegend() + NoAxes()

print(day11)
```


```{r, eval=TRUE, echo=TRUE}
# Highlight time-course day 15 clusters
cells15_0 <- Cells(subset(x = int_obj, subset = Day == "Day 15" & seurat_clusters == 0))
cells15_1 <- Cells(subset(x = int_obj, subset = Day == "Day 15" & seurat_clusters == 1))
cells15_2 <- Cells(subset(x = int_obj, subset = Day == "Day 15" & seurat_clusters == 2))
cells15_3 <- Cells(subset(x = int_obj, subset = Day == "Day 15" & seurat_clusters == 3))
cells15_4 <- Cells(subset(x = int_obj, subset = Day == "Day 15" & seurat_clusters == 4))
cells15_5 <- Cells(subset(x = int_obj, subset = Day == "Day 15" & seurat_clusters == 5))
cells15_6 <- Cells(subset(x = int_obj, subset = Day == "Day 15" & seurat_clusters == 6))

day15 <- DimPlot(object = int_obj, cells.highlight = list(cells15_0, cells15_1, cells15_2, cells15_3, cells15_4, cells15_5, cells15_6), cols.highlight = c("#AA4499", "#332288", "#44AA99", "#999933", "#CC6677", "#882255", "#117733"), cols = "#DDDDDD", order = TRUE, label = FALSE, raster = TRUE, raster.dpi = c(1024, 1024)) +
  ggtitle("Time-course (day 15)") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 11),
    panel.border = element_rect_round(radius = unit(0.1, "snpc"), color = "black", fill = NA)
  ) + NoLegend() + NoAxes()

print(day15)
```


```{r, eval=TRUE, echo=TRUE}
# Highlight guided differentiation ('EB') clusters
cellsEB_0 <- Cells(subset(x = int_obj, subset = Day == "EB" & seurat_clusters == 0))
cellsEB_1 <- Cells(subset(x = int_obj, subset = Day == "EB" & seurat_clusters == 1))
cellsEB_2 <- Cells(subset(x = int_obj, subset = Day == "EB" & seurat_clusters == 2))
cellsEB_3 <- Cells(subset(x = int_obj, subset = Day == "EB" & seurat_clusters == 3))
cellsEB_4 <- Cells(subset(x = int_obj, subset = Day == "EB" & seurat_clusters == 4))
cellsEB_5 <- Cells(subset(x = int_obj, subset = Day == "EB" & seurat_clusters == 5))
cellsEB_6 <- Cells(subset(x = int_obj, subset = Day == "EB" & seurat_clusters == 6))

EB <- DimPlot(object = int_obj, cells.highlight = list(cellsEB_0, cellsEB_1, cellsEB_2, cellsEB_3, cellsEB_4, cellsEB_5, cellsEB_6), cols.highlight = c("#AA4499", "#332288", "#44AA99", "#999933", "#CC6677", "#882255", "#117733"), cols = "#DDDDDD", order = TRUE, label = FALSE, raster = TRUE, raster.dpi = c(1024, 1024)) +
  ggtitle("Guided differentiation (single collection)") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 11),
    panel.border = element_rect_round(radius = unit(0.1, "snpc"), color = "black", fill = NA)
  ) + NoLegend() + NoAxes()

print(EB)
```


```{r, eval=TRUE, echo=TRUE}
# Setup layout for printing multiple plots
p1 <- ggplot(mtcars) + geom_point(aes(mpg, disp))
p2 <- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear))
p3 <- ggplot(mtcars) + geom_bar(aes(gear)) + facet_wrap(~cyl)

# Define the layout for UMAP plots
umap_layout <- c(area(1, 1), area(1, 2), area(1, 3), area(2, 1), area(2, 2), area(2, 3), area(3, 1), area(3, 2, 4, 3))

# Plot each time-course day and the guided differentiation
p <- day0 + day1 + day3 + day5 + day7 + day11 + day15 + EB + plot_layout(design = umap_layout)

print(p)
```


```{r, eval=TRUE, echo=FALSE}
# Function to calculate aspect ratio of ggplot
calculateAspectRatio <- function(plot, defaultAspectRatio = -1) {
  plotBuild <- ggplot_build(plot)
  aspectRatio <- plotBuild$plot$coordinates$ratio
  plotTable <- ggplot_gtable(plotBuild)
  widthsNull <- sapply(plotTable$widths, attr, "unit")
  heightsNull <- sapply(plotTable$heights, attr, "unit")
  if (any(widthsNull == "null"))
    aspectRatio <- unlist(plotTable$widths[widthsNull == "null"]) / unlist(plotTable$heights[heightsNull == "null"])
  if (is.null(aspectRatio)) aspectRatio <- defaultAspectRatio
  aspectRatio[1]
}

# Uncomment to save the last plot with specified settings
ggsave(filename = "fig2_13Nov23.tiff",  width = 7, dpi = 600, plot = last_plot(), device = tiff, scale = 1, limitsize = TRUE, bg = NULL)
```


```{r, eval=TRUE, echo=TRUE}
# Plot UMAP for the entire integrated dataset
p <- DimPlot(int_obj, reduction = "umap", cols = my_seven_colors, order = FALSE, raster = TRUE, raster.dpi = c(1024, 1024)) + 
  theme(
    axis.title.y = element_text(size = 8, color = "black"),
    axis.ticks.y = element_blank(),
    axis.text.y = element_blank(),
    axis.title.x = element_text(size = 8, colour = "black"),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    panel.background = element_blank()
  ) +
  xlab("UMAP 1") + ylab("UMAP 2")

print(p)
```


```{r, eval=TRUE, echo=FALSE}
# Function to calculate aspect ratio of ggplot
calculateAspectRatio <- function(plot, defaultAspectRatio = -1) {
  plotBuild <- ggplot_build(plot)
  aspectRatio <- plotBuild$plot$coordinates$ratio
  plotTable <- ggplot_gtable(plotBuild)
  widthsNull <- sapply(plotTable$widths, attr, "unit")
  heightsNull <- sapply(plotTable$heights, attr, "unit")
  if (any(widthsNull == "null"))
    aspectRatio <- unlist(plotTable$widths[widthsNull == "null"]) / unlist(plotTable$heights[heightsNull == "null"])
  if (is.null(aspectRatio)) aspectRatio <- defaultAspectRatio
  aspectRatio[1]
}

# Uncomment to save the last plot with specified settings
#ggsave(filename = "figS4A_13Nov23.tiff",  width = 7, dpi = 600, plot = last_plot(), device = tiff, scale = 1, limitsize = TRUE, bg = NULL)
```


```{r, eval=TRUE, echo=TRUE}
# While UMAP embedding and clustering are done with the integrated assay, the corrected values are no longer reliable as the quantitative measure of gene expression
# For performing differential expression after integration, switch back to the original data
DefaultAssay(int_obj) <- "SCT"

# Plot marker gene expression by cluster, split by origin
features <- c("KDR", 
              "APOA1", 
              "FOXA2", 
              "CRABP2", 
              "POU5F1", 
              "CCND1", 
              "LUM",
              "COL3A1", 
              "TNNT2", 
              "TTN")

p <- DotPlot(int_obj, features = features, cols = c("#0077BB", "#EE7733"), 
             split.by = "Origin", dot.scale = 8) +
  coord_flip() +
  theme(
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
    axis.title.y = element_blank(),
    axis.title.x = element_blank()
  )

print(p)
```


```{r, eval=TRUE, echo=FALSE}
# Function to calculate aspect ratio of ggplot
calculateAspectRatio <- function(plot, defaultAspectRatio = -1) {
  plotBuild <- ggplot_build(plot)
  aspectRatio <- plotBuild$plot$coordinates$ratio
  plotTable <- ggplot_gtable(plotBuild)
  widthsNull <- sapply(plotTable$widths, attr, "unit")
  heightsNull <- sapply(plotTable$heights, attr, "unit")
  if (any(widthsNull == "null"))
    aspectRatio <- unlist(plotTable$widths[widthsNull == "null"]) / unlist(plotTable$heights[heightsNull == "null"])
  if (is.null(aspectRatio)) aspectRatio <- defaultAspectRatio
  aspectRatio[1]
}

# Uncomment to save the last plot with specified settings
#ggsave(filename = "figS4B_13Nov23.tiff",  width = 7, dpi = 600, plot = last_plot(), device = tiff, scale = 1, limitsize = TRUE, bg = NULL)
```


**FIGURE 3 PLOTTING OF SCPRED / AUTOMATED CELL ANNOTATION**
```{r, eval=TRUE, echo=TRUE}
# Read in reference data from Miao 2020
miao_meta_data <- read.table(file = "integration_analyses/Miao_2020/metadata.txt", 
                             sep = '\t', header = TRUE)
miao_raw_data <- read.table(file = "integration_analyses/Miao_2020/expression.txt", 
                            sep = '\t', header = TRUE)

# Remove first row of metadata (dataclass of each column)
miao_meta_data <- miao_meta_data[-1,]

# Set first column as row names
miao_meta_fix <- miao_meta_data[,-1]
rownames(miao_meta_fix) <- miao_meta_data[,1]
miao_raw_fix <- miao_raw_data[,-1]
rownames(miao_raw_fix) <- miao_raw_data[,1]

# Create Seurat object
miao_reference <- CreateSeuratObject(counts = miao_raw_fix, 
                                     meta.data = miao_meta_fix, 
                                     min.cells = 1)

# Correct spelling in metadata
miao_reference@meta.data$Cell_type <- gsub("Epicarduim", "Epicardium", 
                                           miao_reference@meta.data$Cell_type)
```


```{r, eval=TRUE, echo=TRUE}
# Add origin info to reference object metadata
miao_reference <- AddMetaData(miao_reference, 
                              metadata="Miao_fetal_heart", 
                              col.name="Origin")

# Apply SCTransform, PCA, UMAP, and FindNeighbors
miao_reference <- SCTransform(miao_reference, 
                              variable.features.n = 5000, 
                              verbose = FALSE)
miao_reference <- RunPCA(miao_reference, npcs = 50, verbose = FALSE) 
miao_reference <- RunUMAP(miao_reference, dims = 1:50, verbose = FALSE, 
                          return.model = TRUE)
miao_reference <- FindNeighbors(miao_reference, dims = 1:50, verbose = FALSE)

# Train classifiers with scPred
miao_reference <- getFeatureSpace(miao_reference, "Cell_type")
miao_reference <- trainModel(miao_reference)
```


```{r, eval=TRUE, echo=TRUE}
# Read in guided differentiation culture
guided_obj <- CreateSeuratObject(Read10X("guided_differentiation_2021/220510_A00639_1151_BH3YKKDRX2-YG-EM-17S-lns12/YG-EM-ln1-EM314_human/outs/filtered_feature_bc_matrix/"), min.cells = 1)

# Read in day 100 multi-lineage organoid from Silva 2021
silva_obj <- CreateSeuratObject(Read10X("integration_analyses/Silva_2021/filtered_feature_bc_matrix/"), min.cells = 1)

# Read in PBMCs (negative control)
pbmc_data <- CreateSeuratObject(Read10X("integration_analyses/20k_pbmc/filtered_feature_bc_matrix/"), min.cells = 1)
```


```{r, eval=TRUE, echo=TRUE}
# Create Seurat object from raw data
guided_obj <- CreateSeuratObject(guided_raw_data, min.cells = 1)

# Function to add Vireo metadata
add_vireo_metadata <- function(guided_obj, dir) {
  donor_ids_path <- paste0(dir, 'vireo/donor_ids.tsv')
  ambient_file_path <- paste0(dir, 'vireo/prop_ambient.tsv')
  
  donor_ids <- read.table(donor_ids_path,
                          header = TRUE, 
                          stringsAsFactors = FALSE)
  
  guided_obj <- AddMetaData(guided_obj, 
                            donor_ids$donor_id, 'vireo.individual')
  
  guided_obj <- AddMetaData(guided_obj, 
                            donor_ids$prob_max, 'vireo.prob.singlet')
  
  if (file.exists(ambient_file_path)) {
    prop <- read.table(ambient_file_path, header = TRUE, 
                       stringsAsFactors = FALSE)
    inds <- unique(donor_ids$best_singlet)
    donor_ids$prop_donor <- rep(0, nrow(donor_ids))
    for (i in inds) {
      donor_ids$prop_donor[donor_ids$best_singlet == i] <- prop[inds == i]
    }
    guided_obj <- AddMetaData(guided_obj, 
                              donor_ids$prop_donor, 'vireo.prop.donor')
  }
  guided_obj
}

# Apply function to Seurat object
guided_obj <- add_vireo_metadata(guided_obj, dir)

# Define individual column name
individual_colname <- 'vireo.individual'

# Filter guided obj for assigned singlets containing ≥1,500 features per cell
guided_obj <- subset(guided_obj, 
                     subset = vireo.individual != "doublet" & 
                       vireo.individual != "unassigned" & 
                       nFeature_RNA >= 1500)

# Apply SCTransform and add metadata to guided obj
guided_obj <- SCTransform(guided_obj, variable.features.n = 5000, 
                          verbose = FALSE)
guided_obj <- AddMetaData(guided_obj, 
                          metadata = "guided_obj", 
                          col.name = "Origin")
```


```{r, eval=TRUE, echo=TRUE}
# Filter Silva obj based on # of features, apply SCTransform, add metadata
silva_obj <- subset(silva_obj, subset = nFeature_RNA >= 1500)
silva_obj <- SCTransform(silva_obj, variable.features.n = 5000, verbose = FALSE)
silva_obj <- AddMetaData(silva_obj, 
                         metadata="multi-lineage organoid", 
                         col.name="Origin")

# Apply SCTransform to pbmcs and add metadata
pbmc_data <- SCTransform(pbmc_data, variable.features.n = 5000, verbose = FALSE)
pbmc_data <- AddMetaData(pbmc_data, 
                         metadata="PBMCs", 
                         col.name="Origin")
```


```{r, eval=TRUE, echo=TRUE}
# Set probability threshold for cell classification
threshold_value <- 0.9

# Classify query cells
guided_obj <- scPredict(guided_obj, miao_reference, threshold = threshold_value)
silva_obj <- scPredict(silva_obj, miao_reference, threshold = threshold_value)
pbmc_data <- scPredict(pbmc_data, miao_reference, threshold = threshold_value)
```


```{r, eval=TRUE, echo=TRUE}
# Subset classified cells and plot them (unclassified cells will not be plotted)
sub_guided_obj <- subset(guided_obj, 
                         subset = scpred_prediction == "unassigned", 
                         invert = TRUE)
sub_guided_obj <- RunUMAP(sub_guided_obj, 
                          reduction = "scpred", dims = 1:50, verbose = FALSE)

sub_silva_obj <- subset(silva_obj, 
                        subset = scpred_prediction == "unassigned", 
                        invert = TRUE)
sub_silva_obj <- RunUMAP(sub_silva_obj, 
                         reduction = "scpred", dims = 1:50, verbose = FALSE)

sub_pbmc_data <- subset(pbmc_data, 
                        subset = scpred_prediction == "unassigned", 
                        invert = TRUE)
sub_pbmc_data <- RunUMAP(sub_pbmc_data, 
                         reduction = "scpred", dims = 1:50, verbose = FALSE)
```


```{r, eval=TRUE, echo=TRUE}
# Define color palette
colors <- brewer.pal(11, 'Paired')

# Plot UMAPs
# colors for UMAP plots
colors <- brewer.pal(n = 11, name = 'Paired')


# Plot UMAPs
ref_plot <- DimPlot(object = miao_reference, reduction = "umap", 
                    group.by = "Cell_type", label = TRUE, repel = TRUE, 
                    cols = c("#A6CEE3", 
                             "#1F78B4", 
                             "#B2DF8A", 
                             "#33A02C", 
                             "#FB9A99", 
                             "#E31A1C", 
                             "#FDBF6F", 
                             "#FF7F00", 
                             "#CAB2D6", 
                             "#6A3D9A", 
                             "#FFFF99")) + 
  theme(axis.title.y = element_text(size = 8, color = "black"),
        axis.ticks.y=element_blank(),
        axis.text.y = element_blank(),
        axis.title.x = element_text(size = 8, colour = "black"),
        axis.text.x = element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank()) +
        xlab("UMAP 1") + ylab("UMAP 2") +
        ggtitle(NULL) +
        NoLegend()

guided_plot <- DimPlot(sub_guided_obj, 
                       group.by = "scpred_prediction", label = TRUE, repel = TRUE, 
                       cols = c("#A6CEE3", 
                                "#1F78B4", 
                                "#B2DF8A", 
                                "#33A02C", 
                                "#FB9A99", 
                                "#E31A1C", 
                                "#FDBF6F", 
                                "#FF7F00", 
                                "#CAB2D6", 
                                "#6A3D9A")) + 
  theme(axis.title.y = element_text(size = 8, color = "black"),
        axis.ticks.y=element_blank(),
        axis.text.y = element_blank(),
        axis.title.x = element_text(size = 8, colour = "black"),
        axis.text.x = element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank()) +
        xlab("UMAP 1") + ylab("UMAP 2") +
        ggtitle(NULL) +
        NoLegend()

silva_plot <- DimPlot(sub_silva_obj, 
                      group.by = "scpred_prediction", label = TRUE, repel = TRUE, 
                      cols = c("#A6CEE3", 
                               "#1F78B4", 
                               "#33A02C", 
                               "#E31A1C", 
                               "#FDBF6F", 
                               "#CAB2D6", 
                               "#6A3D9A", 
                               "#FFFF99")) + 
  theme(axis.title.y = element_text(size = 8, color = "black"),
        axis.ticks.y=element_blank(),
        axis.text.y = element_blank(),
        axis.title.x = element_text(size = 8, colour = "black"),
        axis.text.x = element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank()) +
        xlab("UMAP 1") + ylab("UMAP 2") +
        ggtitle(NULL) +
        NoLegend()
```


```{r, eval=TRUE, echo=TRUE}
# Setup layout for multiple plots and print
umaps_layout <- c(area(1, 1), area(2, 1), area(2, 2))
p <- ref_plot + guided_plot + silva_plot + plot_layout(design = umaps_layout)

print(p)
```


```{r, eval=TRUE, echo=FALSE}
# Function to calculate aspect ratio of ggplot
calculateAspectRatio <- function(plot, defaultAspectRatio = -1) {
  plotBuild <- ggplot_build(plot)
  aspectRatio <- plotBuild$plot$coordinates$ratio
  plotTable <- ggplot_gtable(plotBuild)
  widthsNull <- sapply(plotTable$widths, attr, "unit")
  heightsNull <- sapply(plotTable$heights, attr, "unit")
  if (any(widthsNull == "null"))
    aspectRatio <- unlist(plotTable$widths[widthsNull == "null"]) / unlist(plotTable$heights[heightsNull == "null"])
  if (is.null(aspectRatio)) aspectRatio <- defaultAspectRatio
  aspectRatio[1]
}

# Uncomment to save the last plot with specified settings
#ggsave(filename = "fig3_13Nov23.tiff",  width = 7, dpi = 600, plot = last_plot(), device = tiff, scale = 1, limitsize = TRUE, bg = NULL)
```


```{r, eval=TRUE, echo=TRUE}
# Plot PBMC UMAP for supplemental materials
p <- DimPlot(sub_pbmc_data, 
             group.by = "scpred_prediction", label = TRUE, repel = TRUE, 
             cols = c("#FDBF6F")) + 
  theme(axis.title.y = element_text(size = 8, color = "black"),
        axis.ticks.y=element_blank(),
        axis.text.y = element_blank(),
        axis.title.x = element_text(size = 8, colour = "black"),
        axis.text.x = element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank()) +
        xlab("UMAP 1") + ylab("UMAP 2") +
        ggtitle(NULL)

print(p)
```


```{r, eval=TRUE, echo=FALSE}
# Function to calculate aspect ratio of ggplot
calculateAspectRatio <- function(plot, defaultAspectRatio = -1) {
  plotBuild <- ggplot_build(plot)
  aspectRatio <- plotBuild$plot$coordinates$ratio
  plotTable <- ggplot_gtable(plotBuild)
  widthsNull <- sapply(plotTable$widths, attr, "unit")
  heightsNull <- sapply(plotTable$heights, attr, "unit")
  if (any(widthsNull == "null"))
    aspectRatio <- unlist(plotTable$widths[widthsNull == "null"]) / unlist(plotTable$heights[heightsNull == "null"])
  if (is.null(aspectRatio)) aspectRatio <- defaultAspectRatio
  aspectRatio[1]
}

# Uncomment to save the last plot with specified settings
#ggsave(filename = "figS5_13Nov23.tiff",  width = 7, dpi = 600, plot = last_plot(), device = tiff, scale = 1, limitsize = TRUE, bg = NULL)
```


**SOFTWARE INFORMATION**
```{r, eval=TRUE, echo=TRUE}
print(sessionInfo())
```

